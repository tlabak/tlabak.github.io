<!DOCTYPE html>
<html lang="en" id="top">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Trey's Website">
    <meta name="author" content="Trey">
    
     <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    
    <title>VLSI Case Study</title>

    <!-- CSS styling -->
    <link rel="stylesheet" href="/STYLE/charcoal-yellow.css">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Sora:wght@300&display=swap" rel="stylesheet">
    
</head>
<body>
    <!-- Navigation bar -->
    <nav class="navbar">
        <ul>
            <li><a href="./index.html" id="back-link">back</a></li>
            <li><a class="page-scroll" href="#overview">overview</a></li>
            <li><a class="page-scroll" href="#media">media</a></li>
            <li><a class="page-scroll" href="#description">description</a></li>
        </ul>
    </nav>
    
    <!-- Content sections -------------------------------------------------------------------->
    <!-- intro section -->
    <div class="intro-container">
        <!-- Intro section -->
        <section id="intro">
            <div style="float:left; width:60%;">
                <h1>this is <span style="color:#FEE715;"><b>VLSI Case Study.</b></span></h1>
                <h2>VLSI | Verilog HDL | Digital Design</h2>
                <p>This case study focuses on analyzing the performance of different 32-bit pipelined CPU designs and comparing the delays, power consumption, and processing frequency of various full-bit adder architectures. Additionally, a new ALU architecture is proposed and evaluated against the existing full-adder designs to enhance the CPU's speed and performance.</p>
            </div>
            <!-- Project Image -->
            <div class="icon-container" style="float:right; width:40%;">
                    <img src="/IMAGES/vlsi-cpu.jpg" width="360" height="330">
            </div> 
        </section>
    </div>
    
    <hr>

    <!-- portfolio section -->
    <div class="overview-container">
        <section id="overview">
            <h1>Overview</h1>
            <p>The purpose of this case study is to gain a further understanding of different 32-bit pipelined central processing unit (CPU) designs' performance; the comparison between different full-bit adders to showcase the delays, power consumption, and processing frequency of each design. Coupled with the concern of having a fast, high-performing CPU, a new arithmetic logic unit (ALU) architecture should be implemented and compared to the pre-existing full-adder designs. A pipelined CPU is capable of handling many instructions at once, and in this design, the CPU uses 32-bit length words, therefore the architecture for processing a plethora of computations in unison becomes critical in its front-end and back-end design optimization. The integration of the CPU is synchronized by an external clock and other signals to direct operations and operands for the ALU and instructions for addressing the memory file. Using the environments Cadence Virtuoso, Xcelium, Genus, and Innovus, along with the RTL design being written in Verilog HDL, allowed for the compilation, construction, and simulation of developing a high-performing, fast processing CPU.</p>
        </section>
    </div>
        
    <!-- About section -->
    <div class="media-container">
        <section id="media">
            <h1>Media</h1>
            <div class="three-columns">
                <div class="box"><br><img src="/IMAGES/vhdl.jpg" width="330" height="330"></div>
                <div class="box"><br><img src="/IMAGES/vlsi1.jpg" width="330" height="330"></div>
                <div class="box"><br><img src="/IMAGES/cpu-waveform.JPG" width="330" height="330"></div>
            </div>
        </section>
    </div>
    
    <hr>
    
    <!-- Contact section -->
    <div class="description-container">
        <section id="description">
            <h1>Description</h1>
            <ol>
                <li><h2>Full-Bit Adder Circuits</h2></li>
                <ul>
                    <li>In this case study, four types of full-bit adder circuits are compared: carry ripple adder (CRA), carry lookahead adder (CLA), carry skip adder (CSA), and carry select adder (CSeA). These adder circuits are essential components of a 32-bit CPU and are evaluated based on their performance, delays, and speed. Each adder design follows the same test bench Verilog file, but they differ in their topology and processing methods, aiming to achieve an ideal ALU (Arithmetic Logic Unit) block.</li>
                    <br>
                    <ol>
                        <li>Carry Ripple Adder (CRA)</li>
                        <ul><li>The Carry Ripple Adder (CRA) is the simplest adder design among the four compared in the case study. It consists of n-bit full adders that are connected in a cascade, where the carry output of one stage becomes the carry input of the next stage. The main advantage of CRA is its simplicity, as it requires minimal hardware. However, its performance is limited by the sequential nature of the carry propagation, resulting in longer propagation delays. As a result, the CRA design may not be suitable for applications that require fast addition operations.</li></ul>
                        <img style="display:block; margin:0 auto;" src="/IMAGES/CRA.jpg" width="780" height="240">
                        <li>Carry Lookahead Adder (CLA)</li>
                        <ul><li>The Carry Lookahead Adder (CLA) design improves upon the CRA by incorporating additional logic circuits to compute the carry signals in parallel, rather than relying on sequential carry propagation. This parallel computation reduces the carry propagation delay significantly, resulting in faster addition operations compared to CRA. However, the implementation of additional logic circuits introduces more complex hardware, increasing the area and power requirements of the CLA design. It may also lead to increased design complexity and higher manufacturing costs.</li></ul>
                        <img style="display:block; margin:0 auto;" src="/IMAGES/CLA.jpg" width="560" height="320">
                        <li>Carry Skip Adder (CSA)</li>
                        <ul><li>The Carry Skip Adder (CSA) design aims to further enhance the speed of addition operations by dividing the operands into separate blocks, each containing CRA circuits. These blocks perform the addition operations in parallel, allowing for concurrent computation of carry signals. By utilizing parallelism, CSA achieves faster addition speeds compared to both CRA and CLA. However, CSA requires additional hardware for block division and skip logic, which increases the overall complexity, area, and power consumption of the adder design. This additional hardware may also introduce additional delay, affecting critical timing paths.</li></ul>
                        <img style="display:block; margin:0 auto;" src="/IMAGES/CSA.jpg" width="560" height="260">
                        <li>Carry Select Adder (CSeA)</li>
                        <ul><li>The Carry Select Adder (CSeA) design shares similarities with the CSA, as it also divides the bit operations into blocks. However, in addition to dividing the operands, CSeA divides the operations of each bit and incorporates hard-coded carry-in signals. This eliminates the reliance on carry signals from other adders, reducing the critical path delay. By implementing two separate summations, each with a predetermined carry bit (0 and 1), CSeA effectively reduces the propagation delay associated with carry generation. Furthermore, the inclusion of a multiplexer layer that selects the original carry input bit allows for additional flexibility in carry propagation. However, the additional hardware for carry selection and the multiplexer layer increase the complexity, area, and power consumption of the CSeA design.</li></ul>
                        <img style="display:block; margin:0 auto;" src="/IMAGES/CSeA.jpg" width="560" height="360">
                    </ol>
                </ul>
                <li><h2>New ALU Architecture</h2></li>
                <ul>
                    <li>The new ALU architecture aims to optimize the performance, speed, and delay of operations within a CPU. It introduces a 32-bit comparator and a 4x2 multiplexer to enhance the functionality of the ALU. The primary objective of this architecture is to determine the comparative relationship between two 32-bit words stored in registers A and B.</li>
                    <img style="display:block; margin:0 auto;" src="/IMAGES/alu-arch.JPG" width="560" height="240">
                    <li>The 32-bit comparator is a key component of the new ALU architecture. It compares each corresponding pair of bits from the two input words (A and B) and generates binary outputs based on the comparison results. The comparator is implemented using a series of 2-bit comparators, allowing for simultaneous comparison of each bit. This approach enables efficient comparison operations within the ALU.</li>
                    <li>The comparator's output provides information about the relative magnitudes of the two input words. It generates the following output cases:
                        <ol>
                            <li>If A = B: The output of the comparator is "10". This indicates that the two input words A and B are equal.</li>
                            <li>If A > B: The output of the comparator is "01". This suggests that the value stored in register A is greater than the value stored in register B.</li>
                            <li>If A < B: The output of the comparator is "00". This signifies that the value stored in register A is less than the value stored in register B.</li>
                        </ol>
                    </li>
                    <li>The 32-bit comparator plays a crucial role in various applications, such as sorting, searching, and decision-making processes. By providing a straightforward and efficient means of comparing 32-bit words, it enhances the overall functionality and versatility of the ALU. In addition to the comparator, the new ALU architecture includes a series of multiplexers. Specifically, it consists of five layers of multiplexers, with the number of multiplexers decreasing in each subsequent layer until reaching layer 0, which contains a single multiplexer. These multiplexers are responsible for selecting appropriate inputs and determining the desired outputs based on the control signals and comparison results obtained from the 32-bit comparator. They enable the ALU to perform various operations, such as arithmetic calculations, logical operations, and data manipulation, based on the defined control logic.</li>
                </ul>
            </ol>
        </section>
    </div>
    
    <hr>
    
    <!-- OVERLAY --> 
    <div class="overlay" id="overlay">
        <iframe id="iframe" src="" frameborder="0"></iframe>
    </div>

    <!-- JavaScript -------------------------------------------------------------------->
    <script>
        // Wait for the document to be ready
        document.addEventListener('DOMContentLoaded', function() {
            var containers = document.querySelectorAll('.content-container');

            // Function to check if an element is in the viewport
            function isInViewport(element) {
                var rect = element.getBoundingClientRect();
                return (
                    rect.top >= 0 &&
                    rect.left >= 0 &&
                    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                    rect.right <= (window.innerWidth || document.documentElement.clientWidth)
                );
            }

            // Add scroll event listener to check visibility of elements
            window.addEventListener('scroll', function() {
                containers.forEach(function(container) {
                    var titleElement = container.querySelector('.content-container h2');
                    if (titleElement && isInViewport(container)) {
                        titleElement.classList.add('.content-container h2');
                    } else {
                        titleElement.classList.remove('.content-container h2');
                    }
                });
            });
        });
        
        // Scrolling Animation
        document.addEventListener('DOMContentLoaded', function() {
            // Get all elements with the 'page-scroll' class
            var pageScrollLinks = document.getElementsByClassName('page-scroll');

            // Add click event listeners to each page-scroll link
            for (var i = 0; i < pageScrollLinks.length; i++) {
                pageScrollLinks[i].addEventListener('click', scrollToElement);
            }

            // Function to scroll to the target element
            function scrollToElement(event) {
                event.preventDefault(); // Prevent the default link behavior

                // Get the href attribute of the clicked link
                var targetId = this.getAttribute('href');

                // Scroll smoothly to the target element
                document.querySelector(targetId).scrollIntoView({
                    behavior: 'smooth'
                });
            }
        });
        
        // Page Transition
        document.getElementById('back-link').addEventListener('click', function(e) {
            e.preventDefault();
            slideToPage('./index.html');
        });

        function slideToPage(pageURL) {
            const overlay = document.getElementById('overlay');
            const iframe = document.getElementById('iframe');

            overlay.style.transform = 'translateX(0)';
            iframe.src = pageURL;

            // Change the main window's location after a delay to allow the transition to start
            setTimeout(() => {
                window.location.href = pageURL;
            }, 350);
        }
		</script>
</body>
</html>
